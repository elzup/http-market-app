# マーケットアプリ 技術仕様書

## 1. 目的

JavaScript とネットワークプログラミングの学習を目的とした、軽量なマーケットアプリ。すべての商品取引は HTTP または WebSocket 経由で、自分または他者が立てたサーバーとの通信で行われます。

---

## 2. 用語と概念

| 用語                     | 定義                                                   |
| ------------------------ | ------------------------------------------------------ |
| **仕入れポイント（PP）** | 1 PP = 1 円に相当する内部ポイント。初期値：**1 億 PP** |
| **資金（円）**           | 現金資産。初期値：**1 億円**                           |
| **商品**                 | 各学生が定義する名前と価格を持つ 1 種類の品物。        |
| **IP アドレス**          | 各学生の識別子として使用。                             |

---

## 3. 初期状態

```json
{
  "ipAddress": "xxx.xxx.xxx.xxx",
  "capitalYen": 100000000,
  "procurementPts": 100000000,
  "inventory": [],
  "orders": []
}
```

---

## 4. ビジネスルール

1. **商品登録**

   - 各学生は、商品名と価格（¥）を 1 回だけ登録できる。
   - `数量 = floor(仕入れPP / 商品価格)`
   - `数量 × 商品価格` 分の PP が消費され、在庫に数量が加わる。
   - 自店に購入 API を立てて公開。

2. **マーケット登録**

   - 学生は、自店の `商品名・価格・サーバーアドレス（IP:PORT）` を教師サーバーへ送信。
   - 教師サーバーがマーケット一覧を保持。

3. **マーケット取得と通信確認**

   - 各学生は定期的に教師サーバーからマーケット情報を取得し、他店の API が起動中か確認。

4. **購入 (クライアント → 他店)**

   - 他店の `/buy` エンドポイントに HTTP リクエストして取引を確定。
   - バリデーション後、売り手・買い手双方にレスポンスが返る。

5. **資産更新（自動）**

   - **売り手側サーバー** : 受け取った `totalPrice` を `capitalYen` に加算し、在庫 (`inventory`) を減算。
   - **買い手クライアント** : `capitalYen` から支払額を差し引き、`collection` 配列に `{ product, qty }` を追加。
   - どちらも共通の `assets.json` を通じて状態を永続化（`db.js` 経由）。

---

## 4.6 設定・初期化フローと状態遷移

### 教師サーバー側セットアップ

1. **起動**: `central-server.js` を実行し `markets.json` をロード（存在しなければ空配列を作成）。
2. **受付開始**: `POST /register` と `GET /markets` をリッスン。
3. **ヘルスチェック**: 30 秒ごとに登録済みアドレスへ `GET /health` を送信し、応答がなければ `status = "OFFLINE"` に更新。

### 学生サーバー側セットアップ

1. **起動**: `my-store.js` を実行 → `assets.json` と `product.json` をロード。ファイルが無ければ生成。
2. **商品定義**: 初回起動ウィザードで商品名・価格を入力し、在庫数量を計算。
3. **API 公開**: `/buy` と `/health` エンドポイントを立ち上げ。
4. **マーケット登録**: 教師サーバーへ `POST /register` を送信。
5. **マーケット同期**: 15 秒ごとに `GET /markets` で最新リスト取得。
6. **購入処理**: UI 操作で他店の `/buy` にリクエスト。成功後 `assets.json` を更新。

### 状態遷移（学生サーバー）

| State        | 説明                                         | 遷移条件                          |
| ------------ | -------------------------------------------- | --------------------------------- |
| `INIT`       | プロセス起動直後、ローカルファイル読み込み中 | 読み込み完了 → `CONFIGURED`       |
| `CONFIGURED` | 商品情報・在庫計算済み                       | `/register` 成功 → `REGISTERED`   |
| `REGISTERED` | 教師マーケットに登録済み                     | 自サーバー `/buy` 有効 → `ACTIVE` |
| `ACTIVE`     | 売買処理を受け付け中                         | シャットダウン要求 → `SHUTDOWN`   |
| `SHUTDOWN`   | 保存＆クリーンアップ                         | 完了でプロセス終了                |

### 状態遷移（注文）

`NEW → PENDING_MATCH → MATCHED → SETTLED / FAILED`

---

## 5. システム構成

```
┌─────────────┐       登録        ┌──────────────┐
│  学生サーバー  ├────────────────▶│ 教師マーケット  │
└────┬────────┘       一覧取得      └────┬─────────┘
     ▲ ▼                                    ▲ ▼
  購入API／購入リクエスト              マーケット一覧を取得
     ▲ ▼                                    ▲ ▼
┌────┴──────┐         ┌────┴──────┐
│  他学生サーバー   │         │  他学生サーバー   │
└────────────┘         └────────────┘
```

---

## 6. API 仕様

### 6.1 学生 → 教師: マーケット登録

`POST /register`

````json
{
  "ip": "192.168.0.10",
  "product": "りんごジュース",
  "priceYen": 120,
  "port": 8080
}
```json
{
  "ip": "192.168.0.10",
  "product": "りんごジュース",
  "priceYen": 120,
  "port": 8080,
  "pubKey": "5283f1..."   // HMAC 用共有キー or 公開鍵
}
````

`POST /register`

```json
{
  "ip": "192.168.0.10",
  "product": "りんごジュース",
  "priceYen": 120,
  "port": 8080
}
```

### 6.2 学生 → 教師: マーケット一覧取得

`GET /markets`

```json
[
  { "product": "りんごジュース", "price": 120, "address": "192.168.0.10:8080" },
  { "product": "コーヒー", "price": 150, "address": "192.168.0.11:8080" }
]
```

### 6.3 他学生 → 学生: 購入リクエスト

`POST /buy`

```json
{
  "product": "りんごジュース",
  "qty": 5
}
```

- リクエストには、購入希望の商品名を明記する（商品名が不一致の場合は拒否する）。
- `req.ip` から Buyer IP を取得し、マーケット登録時の IP と照合する。
- 店サーバーは、対象商品名・在庫数を確認し、数量が足りない・商品名が一致しない場合は `409 Conflict` を返す。

---

## 7. データ保存

- 各学生サーバーは、状態を **ローカル JSON ファイル** に保存する。
- 教師サーバーも同様に、登録マーケット情報をファイルで保持する。
- ファイル I/O は専用モジュール `db.js` で管理し、アプリ本体からは直接 FileSystem API を呼ばない。

---

## 7.5 実装ガイドライン（ミニマム）

### a. 関数設計

- **1 関数 1 役割**、おおむね **15 行以内** を目安にする。
- 非同期処理は `async/await` を用いて **ネスト 2 層以内** に抑える。

### b. ファイル I/O 分離

- `db.js` に以下 2 関数のみを公開し、これ以外で `fs` を直接呼ばない。

  ```js
  // db.js
  import { readFile, writeFile } from 'node:fs/promises'
  export const readJSON = async (path) =>
    JSON.parse(await readFile(path, 'utf8'))
  export const writeJSON = async (path, data) =>
    writeFile(path, JSON.stringify(data, null, 2))
  ```

- `central-server.js` / `my-store.js` などはすべて `db.js` 経由で読み書きし、単体テスト時はモック可能にする。

### c. 資産ファイル `assets.json`

```json
{
  "capitalYen": 100000000,
  "inventory": [{ "product": "りんごジュース", "qty": 833333 }],
  "collection": [{ "product": "コーヒー", "qty": 10 }]
}
```

- 共有資産を一元管理。クライアント UI と店サーバーの双方がこの 1 ファイルを読み書きする。
- 更新はユーティリティ関数 `updateAssets(fn)` を用いて「読み込み → 変更 → 保存」の 3 行パターンに統一。

## 7.6 店サーバーの在庫トランザクション設計

> **目標:** 同時アクセスでも在庫量・資金を一貫した状態で保つ。

### a. トランザクションの流れ

1. **リクエスト受信** `/buy` → `qty`, `sig` 等を検証。
2. **ロック取得**: `fs.openSync('assets.lock', 'wx')` でロックファイルを生成（失敗時はリトライ）。
3. **状態読み込み**: `assets = readJSON('assets.json')`。
4. **検証**: `assets.inventory.qty >= qty` かつ `buyerCapital >= totalPrice` を確認。
5. **更新**

   - 売り手: `inventory.qty -= qty`, `capitalYen += totalPrice`。
   - **トランザクションログ** `transactions.json` へ `{ tradeId, buyerIp, qty, price, ts }` を追記。

6. **書き込み** `writeJSON('assets.json', assets)`。
7. **ロック解除** `fs.unlinkSync('assets.lock')`。
8. **レスポンス** 成功 or 在庫不足（409）。

### b. 取引ログ `transactions.json` 例

```json
[
  {
    "tradeId": "uuid-1",
    "buyer": "192.168.0.22",
    "seller": "192.168.0.10",
    "product": "りんごジュース",
    "qty": 5,
    "price": 120,
    "ts": 1718800400
  }
]
```

- **冪等性**: `tradeId` を Buyer が生成し、Seller は重複チェックで二重計上を防止。

### c. 初学者向けポイント

- ファイルロックにより Race Condition を回避。
- `try/catch/finally` でロック解除漏れを防ぐ実装を推奨。
- トランザクション処理は **processPurchase()** 1 関数に集約し、他ロジックをシンプル化。

---

## 8. セキュリティ（演習向け簡易版）

> 本演習ではセキュリティ強化は行わず、同一端末内での資産整合性の維持に注力する。

### 8.1 シングル資産管理要件

- 各参加者（学生）は **クライアントとサーバーが同一マシン上にある**ことを前提とし、`assets.json` を通じて資金・在庫を一元管理する。
- クライアント UI が購入リクエストを行う際、以下を厳守する：

  - `product`（購入対象の商品名）を明示する
  - `qty`（購入数量）を指定

- 店サーバーは `product` が自分の商品名と一致しているか確認し、一致しない場合は `409 Conflict` を返す。
- IP アドレスを用いてリクエスト元の識別を行う（登録済みの IP と比較）。

### 8.2 最小限のバリデーション

| チェック項目 | 内容                             | 失敗時コード    |
| ------------ | -------------------------------- | --------------- |
| 商品名一致   | `request.product === 自店商品名` | `409 Conflict`  |
| 在庫不足     | `inventory.qty < request.qty`    | `409 Conflict`  |
| IP 不一致    | `req.ip !== 登録済みBuyer IP`    | `403 Forbidden` |

- 購入成立後は、**店サーバーとクライアントの両方**で `assets.json` を即時更新する必要がある。
- 同一資産ファイルの読み書きは `db.js` 経由で行い、競合回避のため `assets.lock` を使用。

---
